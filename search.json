[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Clojure Tidy Tuesdays",
    "section": "",
    "text": "Welcome to Clojure Tidy Tuesdays!\nThis is a collection of #TidyTuesday explorations in Clojure. Tidy Tuesdays are an initiative of the R for data science online learning community, and as a Clojure enthusiast, I’m publishing implementations of the data-generation scripts and data explorations in Clojure here in 2024. Follow along to learn all about Clojure’s rich data ecosystem!\nYou can find more code showing examples and explanations about how to download and wrangle data in the data fetching scripts in the data folder of this project’s repo. They’re not published here as namespaces because many make lots of API calls and/or don’t display nicely as published notebooks.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to Clojure Tidy Tuesdays!</span>"
    ]
  },
  {
    "objectID": "index.html#goals",
    "href": "index.html#goals",
    "title": "Clojure Tidy Tuesdays",
    "section": "Goals",
    "text": "Goals\nSome goals for this project this year are:\n\nTo increase the number of non-trivial examples and guides on how to work with Clojure’s emerging data science stack\nTo work out bugs and rough edges in these tools and libraries to help develop them for more professional use\nTo learn how to use them better myself, as part of writing the Clojure Data Workbook",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to Clojure Tidy Tuesdays!</span>"
    ]
  },
  {
    "objectID": "index.html#support",
    "href": "index.html#support",
    "title": "Clojure Tidy Tuesdays",
    "section": "Support",
    "text": "Support\nThis work is made possible by the ongoing funding I receive from Clojurists together and my generous Github Sponsors. If you find this work valuable, please consider contributing financially to it’s sustainability:\n\n\n\n\n\n\nsource: src/index.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Welcome to Clojure Tidy Tuesdays!</span>"
    ]
  },
  {
    "objectID": "year_2024.week_1.analysis.html",
    "href": "year_2024.week_1.analysis.html",
    "title": "Week 1 - Holiday Movies",
    "section": "",
    "text": "Making a bar chart\nTo get started, we’ll load the data into our notebook, starting with the dataset of holiday movies:\nWe’ll make a graph that’s similar to the one in this article about Christmas movies, showing the top 20 movies by number of votes. For this we’ll use noj, a library that nicely integrates hanami, a Clojure library that wraps vega-lite, with tablecloth. First we can tell it to make a bar chart:\nWe have to tell hanami what values to use in the chart and what they are:\nThis works! We’ll give it a few more options to tidy up the chart, like sorting the bars by number of votes rather than alphabetically and re-labelling the axes:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1 - Holiday Movies</span>"
    ]
  },
  {
    "objectID": "year_2024.week_1.analysis.html#making-a-bar-chart",
    "href": "year_2024.week_1.analysis.html#making-a-bar-chart",
    "title": "Week 1 - Holiday Movies",
    "section": "",
    "text": "(def holiday-movies\n  (tc/dataset \"data/year_2024/week_1/holiday-movies.csv\"))\n\n\n\n(-&gt; holiday-movies\n    ;; sort the movies by number of votes\n    (tc/order-by \"num_votes\" :desc)\n    ;; select the first 20\n    (tc/select-rows (range 20))\n    ;; make a bar chart\n    (hanami/plot ht/bar-chart {}))\n\n\n\n\n\n\n\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    (hanami/plot ht/bar-chart {:X \"num_votes\"\n                               :Y \"primary_title\"\n                               :YTYPE \"nominal\"}))\n\n\n\n\n\n\n\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    (hanami/plot ht/bar-chart {:X \"num_votes\"\n                               :Y \"primary_title\"\n                               :YTYPE \"nominal\"\n                               :YTITLE \"Title\"\n                               :XTITLE \"Number of votes\"\n                               :YSORT \"-x\"}))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1 - Holiday Movies</span>"
    ]
  },
  {
    "objectID": "year_2024.week_1.analysis.html#adding-labels-to-the-bar-chart",
    "href": "year_2024.week_1.analysis.html#adding-labels-to-the-bar-chart",
    "title": "Week 1 - Holiday Movies",
    "section": "Adding labels to the bar chart",
    "text": "Adding labels to the bar chart\nIn order to add the number of votes values next to the bars we’ll have to rearrange some of the vega lite spec.. making this tidier and more intuitive is on the list of projects the Clojure data community is actively working on. I get that right now it requires too much information of vega-lite internals. Also it breaks the sorting and I don’t know why yet..\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    (hanami/plot (assoc ht/layer-chart :encoding :ENCODING)\n                 {:TITLE \"Christmas Movies\"\n                  :X \"num_votes\"\n                  :Y \"primary_title\"\n                  :YTYPE \"nominal\"\n                  :YTITLE \"Title\"\n                  :XTITLE \"Number of votes\"\n                  :YSORT \"-x\"\n                  :WIDTH 500\n                  :XSTACK nil\n                  :LAYER [{:mark {:type \"bar\"}}\n                          {:mark {:type \"text\" :align \"left\" :baseline \"middle\" :dx 3}\n                           :encoding {:text {:field \"num_votes\"}}}]}))\n\n\n\n\n\n\nThis is a similar idea to what’s accomplished in the article. We don’t have exactly the same data, so we can’t encode the Oscar status of each movie in the colour, but we could do something else, like indicate the decade in which the film was released. There are lots of ways to accomplish this. There would be a way to tell vega-lite to do it (via Hanami), but for the sake of exploring Clojure some more we’ll do the data wrangling part with it. To do that we’ll start with our dataset of the 20 most popular movies and add a column for the release decade, then update our plot to have the bars coloured by decade.\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    ;; add a new column for the decade, computed from the year\n    (tc/map-columns \"decade\" [\"year\"] (fn [year]\n                                        (-&gt; year\n                                            (/ 10)\n                                            (Math/floor)\n                                            (* 10)\n                                            int\n                                            (str \"s\"))))\n    ;; colour our bars according to the decade\n    (hanami/plot ht/bar-chart {:X \"num_votes\"\n                               :Y \"primary_title\"\n                               :YTYPE \"nominal\"\n                               :YTITLE \"Title\"\n                               :XTITLE \"Number of votes\"\n                               :YSORT \"-x\"\n                               :COLOR \"decade\"}))\n\n\n\n\n\n\nWithout the bar labels, this is reasonably straightforward.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1 - Holiday Movies</span>"
    ]
  },
  {
    "objectID": "year_2024.week_1.analysis.html#making-a-word-cloud",
    "href": "year_2024.week_1.analysis.html#making-a-word-cloud",
    "title": "Week 1 - Holiday Movies",
    "section": "Making a word cloud",
    "text": "Making a word cloud\nThe next graph in the article is a graph of relationships between the movie keywords. We don’t have the keywords in our dataset, but we could do something with the words of the movie titles, like a word cloud, where the size of the word reflects its occurrence in the movie titles. First we’ll collect all of the words in all the titles into a list, then use those as the data for the word cloud. This is a little more involved with low-level vega details than is ideal right now, but it’s possible.\n\n(let [data (-&gt; holiday-movies\n               (tc/select-columns \"primary_title\")\n               tc/rows\n               flatten)]\n  (kind/vega {:data\n              [{:name \"table\"\n                :values data\n                :transform\n                [{:type \"countpattern\"\n                  :field \"data\"\n                  :case \"upper\"\n                  :pattern \"[\\\\w']{3,}\"\n                  :stopwords \"(the|a|i'm|like|too|into|ing|for|where|she|he|hers|his|how|who|what|your|yours|it|it's|is|are|we|'til|our|and|but|i'll|this|that|from|with)\"\n                  }\n                 {:type \"formula\",\n                  :as \"angle\",\n                  :expr \"[-45, -25, 0, 25, 45][~~(random() * 5)]\"}\n                 {:type \"formula\",\n                  :as \"weight\",\n                  :expr \"if(datum.text=='CHRISTMAS' |\n                            datum.text=='HOLIDAY' |\n                            datum.text=='HANNUKAH', 600, 300)\"}]}],\n              :scales\n              [{:name \"color\"\n                :type \"ordinal\",\n                :domain {:data \"table\", :field \"text\"},\n                :range [\"red\" \"green\" \"grey\" \"darkred\" \"darkgreen\"]}],\n              :marks\n              [{:type \"text\",\n                :from {:data \"table\"},\n                :encode\n                {:enter\n                 {:text {:field \"text\"},\n                  :align {:value \"center\"},\n                  :baseline {:value \"alphabetic\"},\n                  :fill {:scale \"color\", :field \"text\"}},\n                 :update {:fillOpacity {:value 1}},\n                 :hover {:fillOpacity {:value 0.5}}},\n                :transform\n                [{:fontSizeRange [10 56],\n                  :type \"wordcloud\",\n                  :font \"Helvetica Neue, Arial\",\n                  :size [800 400],\n                  :padding 2,\n                  :fontWeight {:field \"datum.weight\"},\n                  :rotate {:field \"datum.angle\"},\n                  :fontSize {:field \"datum.count\"},\n                  :text {:field \"text\"}}]}]}))\n\n\n\n\n\n\nSee you next week :)\n\n\n\n\nsource: src/year_2024/week_1/analysis.clj",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Week 1 - Holiday Movies</span>"
    ]
  },
  {
    "objectID": "year_2024.week_2.analysis.html",
    "href": "year_2024.week_2.analysis.html",
    "title": "Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "",
    "text": "Canadian Birth Months\nThe data for this analysis are gathered from the NHL API and StatsCan. There are a bunch of files saved in data/year_2024/week_2 you can just use, or if you want to explore how the data is collected and cleaned up you can check out data/year_2024/week_2/generate_dataset.clj. We start with data on all Canadian births from 1991-2022 to see the distribution of Canadian births by month.\n_unnamed [12 3]:\nWe can plot this to make it easier to interpret:\nSo now we can see the distribution of births in Canada by month between 1991 and 2022. It actually looks like Canadians are less likely to be born in the earlier months of the year, with the most births in May, July, August, and September. We can compare this to the expected distribution (if each day had an exactly equal chance of being someone’s birthday) by first constructing a dataset of the “expected” monthly distributions:\nAnd then computing the differences between the “expected” monthly births and the actual Canadian data:\ninner-join [12 5]:\nWe can check the distribution for hockey players next.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2 - Canadian NHL Hockey Player Birth Months</span>"
    ]
  },
  {
    "objectID": "year_2024.week_2.analysis.html#canadian-birth-months",
    "href": "year_2024.week_2.analysis.html#canadian-birth-months",
    "title": "Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "",
    "text": "(def canadian-births-by-month\n  (-&gt; \"data/year_2024/week_2/canada_births_1991_2022.csv\"\n      (tc/dataset {:key-fn keyword})\n      ;; group them by month\n      (tc/group-by [:month])\n      ;; count all births per month over the time period\n      (tc/aggregate {:country-births #(reduce + (:births %))})\n      ;; make a new column for the percentage of total births that each monthly total represents\n      (as-&gt; country-births-ds\n            (let [total-births (-&gt;&gt; country-births-ds\n                                    :country-births\n                                    (reduce +))]\n              (tc/map-columns country-births-ds\n                              :country-pct\n                              :country-births\n                              (fn [country-births]\n                                (-&gt; country-births\n                                    (/ total-births)\n                                    double)))))))\n\n\ncanadian-births-by-month\n\n\n\n\n\n:month\n:country-births\n:country-pct\n\n\n\n\n1\n941370\n0.08015265\n\n\n2\n886150\n0.07545096\n\n\n3\n995978\n0.08480224\n\n\n4\n983363\n0.08372814\n\n\n5\n1029538\n0.08765969\n\n\n6\n1001064\n0.08523528\n\n\n7\n1042392\n0.08875414\n\n\n8\n1024021\n0.08718995\n\n\n9\n1019490\n0.08680416\n\n\n10\n982729\n0.08367415\n\n\n11\n918434\n0.07819978\n\n\n12\n920185\n0.07834886\n\n\n\n\n\n(-&gt; canadian-births-by-month\n    (hanami/plot (assoc ht/layer-chart :encoding :ENCODING)\n                 {:TITLE \"Canadian births by month 1991-2022\"\n                  :X :country-births\n                  :XTITLE \"Number of births (cumulatively)\"\n                  ;; vega-lite uses JS sorting, which does not sort numbers\n                  ;; properly, so we'll tell it what order to use explicitly\n                  :YSORT [\"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\"]\n                  :Y :month\n                  :YTITLE \"Month\"\n                  :YTYPE \"nominal\"\n                  :LAYER [{:mark \"bar\"}\n                          {:mark {:type \"text\" :align \"left\" :dx 3}\n                           :encoding {:text {:field :country-pct :format \".1%\"}}}]}))\n\n\n\n\n\n\n\n\n(def expected-births-by-month\n  (let [months [1 2 3 4 5 6 7 8 9 10 11 12]]\n    (tc/dataset {:month months\n                 :expected-births (map (fn [month]\n                                         (double (cond\n                                                   (#{4 6 9 11} month) 30/365\n                                                   (= month 2) 28/365\n                                                   :else 31/365)))\n                                       months)})))\n\n\n\n(-&gt; expected-births-by-month\n    (tc/inner-join canadian-births-by-month :month)\n    (tc/map-columns :difference [:expected-births :country-pct]\n                    (fn [expected country]\n                      (- expected country))))\n\n\n\n\n\n\n\n\n\n\n\n\n:month\n:expected-births\n:country-births\n:country-pct\n:difference\n\n\n\n\n1\n0.08493151\n941370\n0.08015265\n0.00477885\n\n\n2\n0.07671233\n886150\n0.07545096\n0.00126136\n\n\n3\n0.08493151\n995978\n0.08480224\n0.00012927\n\n\n4\n0.08219178\n983363\n0.08372814\n-0.00153635\n\n\n5\n0.08493151\n1029538\n0.08765969\n-0.00272818\n\n\n6\n0.08219178\n1001064\n0.08523528\n-0.00304350\n\n\n7\n0.08493151\n1042392\n0.08875414\n-0.00382263\n\n\n8\n0.08493151\n1024021\n0.08718995\n-0.00225844\n\n\n9\n0.08219178\n1019490\n0.08680416\n-0.00461238\n\n\n10\n0.08493151\n982729\n0.08367415\n0.00125735\n\n\n11\n0.08219178\n918434\n0.07819978\n0.00399201\n\n\n12\n0.08493151\n920185\n0.07834886\n0.00658264",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2 - Canadian NHL Hockey Player Birth Months</span>"
    ]
  },
  {
    "objectID": "year_2024.week_2.analysis.html#canadian-nhl-hockey-player-birth-months",
    "href": "year_2024.week_2.analysis.html#canadian-nhl-hockey-player-birth-months",
    "title": "Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "Canadian NHL Hockey Player Birth Months",
    "text": "Canadian NHL Hockey Player Birth Months\nWe have a dataset that includes player info for all NHL players over all time. We’ll start by doing a similar breakdown to the one we did above for all Canadians.\n\n(def nhl-player-births-by-month\n  ;; first, load the dataset:\n  (-&gt; \"data/year_2024/week_2/nhl-player-births.csv\"\n      (tc/dataset {:key-fn keyword})\n      ;; filter out just Canadian players\n      (tc/select-rows #(= (:birth-country %) \"CAN\"))\n      ;; group the players by birth month\n      (tc/group-by [:birth-month])\n      ;; count the number of players per month\n      (tc/aggregate {:births tc/row-count})\n      ;; we'll add a new column where we compute the percentage of births that each monthly total represents\n      (as-&gt; player-births-ds\n          (let [total-births (-&gt;&gt; player-births-ds\n                                  :births\n                                  (reduce +))]\n            (tc/map-columns player-births-ds\n                            :player-pct\n                            :births\n                            (fn [births]\n                              (-&gt; births\n                                  (/ total-births)\n                                  double)))))))\n\nWe can make a similar bar chart to see how the distribution of hockey player births compares to the all-Canada data:\n\n(hanami/plot nhl-player-births-by-month\n             (assoc ht/layer-chart :encoding :ENCODING)\n             {:TITLE \"NHL player births by month\"\n              :X :births\n              :XTITLE \"Number of births\"\n              ;; vega-lite uses JS sorting, which does not sort numbers properly, so we'll tell it what order to use explicitly\n              :YSORT [\"JANUARY\"\n                      \"FEBRUARY\"\n                      \"MARCH\"\n                      \"APRIL\"\n                      \"MAY\"\n                      \"JUNE\"\n                      \"JULY\"\n                      \"AUGUST\"\n                      \"SEPTEMBER\"\n                      \"OCTOBER\"\n                      \"NOVEMBER\"\n                      \"DECEMBER\"]\n              :Y :birth-month\n              :YTITLE \"Month\"\n              :YTYPE \"nominal\"\n              :LAYER [{:mark \"bar\"}\n                      {:mark {:type \"text\" :align \"left\" :dx 3}\n                       :encoding {:text {:field :player-pct\n                                         :format \".1%\"}}}]})\n\n\n\n\n\n\nThese are definitely more distributed disproportionately through the early months of the year. We can compare them on top of each other to see more clearly next.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2 - Canadian NHL Hockey Player Birth Months</span>"
    ]
  },
  {
    "objectID": "year_2024.week_2.analysis.html#comparing-all-canadian-births-to-canadian-nhl-player-births",
    "href": "year_2024.week_2.analysis.html#comparing-all-canadian-births-to-canadian-nhl-player-births",
    "title": "Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "Comparing all Canadian births to Canadian NHL player births",
    "text": "Comparing all Canadian births to Canadian NHL player births\nWe’ll simplify and combine the datasets first, before visualizing them:\n\n(def combined-births-by-month\n  (let [canada-births (-&gt; canadian-births-by-month\n                        ;; clean up the month names so they are the same in both datasets\n                          (tc/update-columns {:month (fn [col]\n                                                       (map #(-&gt; % Month/of .name str/capitalize)\n                                                            col))}))\n        player-births (-&gt; nhl-player-births-by-month\n                          (tc/rename-columns {:birth-month :month\n                                              :births :player-births})\n                          (tc/update-columns {:month (partial map str/capitalize)}))\n        expected-births (-&gt; expected-births-by-month\n                            (tc/rename-columns {:expected-births :expected-births-pct})\n                            (tc/update-columns {:month (fn [col]\n                                                         (map #(-&gt; % Month/of .name str/capitalize)\n                                                              col))}))]\n    ;; join the datasets by month to make one dataset:\n    (-&gt; canada-births\n        (tc/inner-join player-births :month)\n        (tc/inner-join expected-births :month))))\n\nThe visualization in the linked article is a really great example of where ggplot really shines. I think it would be cool to explore how this might be possible to re-create with vega-lite (via the tools and wrappers we have around it Clojure), but for now we can visualize the data in a more simple way using a grouped bar chart. Since this is a pretty custom chart, I’m going to hand-write the vega-lite spec. There’s tons to learn about vega-lite, but the main takeaway for now is that you can pass any vega-lite (or vega) spec to Clojure’s vega-viz wrappers and it will render them:\n\n(hanami/plot combined-births-by-month\n             {:data {:values :DATA\n                     :format :DFMT}\n              :repeat {:layer [:expected-births-pct :country-pct :player-pct]}\n              :spec {:encoding {:y {:field :month\n                                    :type \"nominal\"\n                                    :axis {:title \"Month\"}\n                                    :sort [\"January\"\n                                           \"February\"\n                                           \"March\"\n                                           \"April\"\n                                           \"May\"\n                                           \"June\"\n                                           \"July\"\n                                           \"August\"\n                                           \"September\"\n                                           \"October\"\n                                           \"November\"\n                                           \"December\"]}}\n                     :layer [{:mark \"bar\"\n                              :height {:step \"12\"}\n                              :encoding {:x {:field {:repeat \"layer\"}\n                                             :type \"quantitative\"\n                                             :axis {:title \"Percentage of births\"\n                                                    :format \".0%\"}}\n                                         :color {:datum {:repeat \"layer\"}\n                                                 :type \"nominal\"\n                                                 :scale {:range [\"steelblue\" \"red\" \"black\"]}\n                                                 :legend {:title \"Group\"\n                                                          :labelExpr \"{'country-pct': 'Canada', 'player-pct': 'NHL Players', 'expected-births-pct': 'Expected'}[datum.label]\"}}\n                                         :yOffset {:datum {:repeat \"layer\"}}}}\n                             {:mark {:type \"text\" :dx -80 :fontSize 10.5}\n                              :encoding {:text {:field {:repeat \"layer\"} :format \".1%\"}\n                                         :color {:value \"white\"}\n                                         :yOffset {:datum {:repeat \"layer\"}}}}]}}\n             {})\n\n\n\n\n\n\nWhen the data are all side-by-side like this we can see pretty clearly that it’s true that NHL players are in fact more likely to be born in the earlier parts of the year.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2 - Canadian NHL Hockey Player Birth Months</span>"
    ]
  },
  {
    "objectID": "year_2024.week_2.analysis.html#chi-squared-test",
    "href": "year_2024.week_2.analysis.html#chi-squared-test",
    "title": "Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "Chi-squared test",
    "text": "Chi-squared test\nThe last thing the author of the original article does is a chi-squared test on the NHL player births distribution. A chi-squared test is one you can use to see whether a given variable follows a hypothesized distribution in a more quantitative way, so it’s basically a more stats-y way to show that the NHL player birth dates distribution is different than we would expect. I.e., it can answer, quantitatively, the question “what are the chances that a sample of birth dates would be distributed the way our NHL player birth dates dataset is, compared to the expected distribution?” In this case our “expected” distribution is based on the distribution by month of all Canadian births.\nIn Clojure, this test is already implemented in the fastmath library, but in the interest of teaching (and because I already did it the hard way first before I learned how to use the fastmath function), we can just do it manually.\nFirst we compute the chi statistic. The formula is \\[\\sum_{k=1}^{n}\\frac{(O_k - E_k)^2}{E_k}\\] where O is the actual value and E is the expected one. We can implement this in Clojure. The first thing we need is the expected values. Our “actual” values are the count of NHL player births by month, so we can compute the expected ones by applying the expected distribution (based on the Canadian births data):\n\n(def actual-and-expected-births\n  ;; first get the total count of player births\n  (let [total-player-births (-&gt;&gt; (tc/select-columns nhl-player-births-by-month [:births])\n                                 tc/rows\n                                 (map first)\n                                 (reduce +))\n\n      ;; clean up the month names so they are the same in both datasets\n        canada-births (-&gt; canadian-births-by-month\n                          (tc/update-columns {:month (fn [col]\n                                                       (map #(-&gt; % Month/of .name str/capitalize)\n                                                            col))}))]\n    ;; combine the Canadian data with the NHL player data to calculate the expected values\n    (-&gt; nhl-player-births-by-month\n        (tc/rename-columns {:birth-month :month\n                            :births :actual})\n        (tc/update-columns {:month (partial map str/capitalize)})\n        (tc/inner-join canada-births :month)\n        (tc/map-columns :expected\n                        [:country-pct]\n                        (fn [pct]\n                          (Math/round (* pct total-player-births))))\n        (tc/select-columns [:month :actual :expected]))))\n\n\nactual-and-expected-births\n\ninner-join [12 3]:\n\n\n\n:month\n:actual\n:expected\n\n\n\n\nJanuary\n542\n438\n\n\nFebruary\n533\n412\n\n\nMarch\n513\n464\n\n\nApril\n526\n458\n\n\nMay\n520\n479\n\n\nJune\n463\n466\n\n\nJuly\n437\n485\n\n\nAugust\n394\n477\n\n\nSeptember\n421\n475\n\n\nOctober\n383\n457\n\n\nNovember\n374\n428\n\n\nDecember\n361\n428\n\n\n\nThis gives us the expected values – the number of births we would expect per month if we randomly sampled the same number of births from the Canadian data as we have NHL player births. Now we can compute the chi squared statistic:\n\n(def chi-squared\n  (-&gt;&gt; (tc/select-columns actual-and-expected-births [:actual :expected])\n       tc/rows\n       (map (fn [[actual expected]]\n              ;; find the difference between the actual and expected values\n              (let [a-e (- actual expected)]\n                (-&gt; a-e\n                    ;; square it\n                    (* a-e)\n                    ;; divide it by the expected value\n                    (/ expected)))))\n       ;; sum them\n       (reduce +)\n       ;; make it a number instead of a fraction\n       double\n       Math/round))\n\n\nchi-squared\n\n\n134\n\nIn order to use this value to test whether our NHL player birth dates follow an “expected” distribution, we can calculate the P-value using a chi-squared distribution. This is also implemented in fastmath, in this case we’ll use it. The P value tells us what the probability is of observing the given discrepancy between the actual and expected values. The degrees of freedom is one less than the number of categories we have, so in our case 11.\n\n(require '[fastmath.stats :as stats])\n\n\n(require '[fastmath.random :as r])\n\n\n(stats/p-value (r/distribution :chi-squared {:degrees-of-freedom 11}) chi-squared)\n\n\n0.0\n\nInterpreting this, we can say there is a 0.0% chance that the NHL player birth data are sampled from the Canadian birth data. In other words, the probability that the NHL player birth distribution by month is a fluke is 0. It’s definitely anomalous, not a result of not having a large enough sample size.\nSo that wraps up our exploration of this data! I’d love to poke around some more and see how the distribution of NHL players by nationality breaks down over time, and play around with vega-lite some more to make cooler looking graphs. But here I am already late for next week’s tidy tuesday, so I’ll move on for now and come back once I’ve learned more.\nSee you next week :)\n\n\n\n\nsource: src/year_2024/week_2/analysis.clj",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Week 2 - Canadian NHL Hockey Player Birth Months</span>"
    ]
  },
  {
    "objectID": "year_2024.week_3.analysis.html",
    "href": "year_2024.week_3.analysis.html",
    "title": "Week 3 - US Polling Places 2012-2020",
    "section": "",
    "text": "Polling location counts over time\nIn order to see which states have had the largest shifts in polling location counts over time, we can group the data by election date and state and then count the number of rows in each group:\n_unnamed [161 3]:\nWe can plot this data to get a glimpse of how the count of polling places per state has changed over time:\nTo make this chart easier to interpret, we’ll change a few things, noted inline below:\nEven this doesn’t really tell us much, other than that most states saw no change in the overall number of polling places over the years (lots of straight lines!). To get a better idea of how the states compare to each other, we can facet this graph by state.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3 - US Polling Places 2012-2020</span>"
    ]
  },
  {
    "objectID": "year_2024.week_3.analysis.html#polling-location-counts-over-time",
    "href": "year_2024.week_3.analysis.html#polling-location-counts-over-time",
    "title": "Week 3 - US Polling Places 2012-2020",
    "section": "",
    "text": "(def all-polling-locations\n  (-&gt; \"data/year_2024/week_3/polling-places.csv\"\n      (tc/dataset {:key-fn keyword})))\n\n\n(-&gt; all-polling-locations\n    (tc/group-by [:election_date :state])\n    (tc/aggregate {:count tc/row-count}))\n\n\n\n\n\n:election_date\n:state\n:count\n\n\n\n\n2020-11-03\nAL\n2075\n\n\n2012-11-06\nAK\n396\n\n\n2014-11-04\nAK\n396\n\n\n2016-11-08\nAK\n396\n\n\n2018-11-06\nAK\n396\n\n\n2020-11-03\nAK\n441\n\n\n2012-11-06\nAR\n2536\n\n\n2014-11-04\nAR\n2972\n\n\n2018-11-06\nAR\n8980\n\n\n2020-11-03\nAR\n967\n\n\n…\n…\n…\n\n\n2020-11-03\nVA\n2485\n\n\n2012-11-06\nWV\n1860\n\n\n2014-11-04\nWV\n1816\n\n\n2016-11-08\nWV\n1759\n\n\n2018-11-06\nWV\n1759\n\n\n2020-11-03\nWV\n1729\n\n\n2012-11-06\nWI\n6587\n\n\n2014-11-04\nWI\n6765\n\n\n2016-11-08\nWI\n6865\n\n\n2018-11-06\nWI\n6995\n\n\n2020-11-03\nWI\n7092\n\n\n\n\n\n(-&gt; all-polling-locations\n    (tc/group-by [:election_date :state])\n    (tc/aggregate {:count tc/row-count})\n    (hanami/plot ht/line-chart\n                 {:X :election_date\n                  :XTYPE :temporal\n                  :Y :count\n                  :COLOR {:field \"state\" :type \"nominal\"}}))\n\n\n\n\n\n\n\n\n(-&gt; all-polling-locations\n    (tc/group-by [:election_date :state])\n    (tc/aggregate {:count tc/row-count})\n    (hanami/plot (-&gt; ht/line-chart\n                     (assoc-in [:mark :strokeWidth] :MSWIDTH)\n                     (assoc-in [:mark :opacity] :MOPACITY))\n                 {:X :election_date\n                  :XTYPE :temporal\n                  :Y :count\n                  ;; make the whole chart wider\n                  :WIDTH 700\n                  ;; make the line widths slightly bigger and more transparent\n                  :MSWIDTH 4\n                  :MOPACITY 0.5\n                  :COLOR {:field \"state\" :type \"nominal\"\n                          ;; get rid of the legend\n                          :legend nil}\n                  ;; replace the legend with tooltips, to see the state when hovering over a point\n                  :MTOOLTIP true\n                  ;; change the y-axis to a logarithmic scale to make it easier to interpret the\n                  ;; wide range of counts\n                  :YSCALE {:type \"log\"}}))",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3 - US Polling Places 2012-2020</span>"
    ]
  },
  {
    "objectID": "year_2024.week_3.analysis.html#faceting-polling-places-over-time-graph",
    "href": "year_2024.week_3.analysis.html#faceting-polling-places-over-time-graph",
    "title": "Week 3 - US Polling Places 2012-2020",
    "section": "Faceting polling places over time graph",
    "text": "Faceting polling places over time graph\n\n(-&gt; all-polling-locations\n    (tc/group-by [:election_date :state])\n    (tc/aggregate {:count tc/row-count})\n    ;; this is pretty messy -- for now we have to manually cobble together\n    ;; the plot specifications in this way, but optimizing these to make\n    ;; them more ergonomic is high on the priority list\n    (hanami/plot (-&gt; ht/line-chart\n                     (assoc :encoding (assoc (hc/get-default :ENCODING)\n                                             :facet\n                                             :FACET)))\n                 {:X :election_date\n                  :XTITLE \"Year\"\n                  :XGRID false\n                  :XTYPE :temporal\n                  :Y :count\n                  :YTITLE \"Count\"\n                  :YGRID false\n                  :HEIGHT 50\n                  :WIDTH 80\n                  :COLOR {:field :state :type :nominal :legend false}\n                  :FACET {:field :state :type :nominal :columns 7 :title \"State\"}}))\n\n\n\n\n\n\nThis is still not super informative (IMO), but better. We can at least clearly see the outliers that did see some change over time, i.e. AR, MD, MN. It also reveals states that have no or little data.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3 - US Polling Places 2012-2020</span>"
    ]
  },
  {
    "objectID": "year_2024.week_3.analysis.html#relative-changes-in-polling-places-by-state",
    "href": "year_2024.week_3.analysis.html#relative-changes-in-polling-places-by-state",
    "title": "Week 3 - US Polling Places 2012-2020",
    "section": "Relative changes in polling places by state",
    "text": "Relative changes in polling places by state\nNext we can try to visualize the relative changes in polling station counts between two years. We can check out which states have data first and see that it probably doesn’t matter much which two years we choose:\n\n(-&gt; all-polling-locations\n    (tc/select-columns [:election_date :state])\n    (tc/unique-by [:election_date :state])\n    (tc/fold-by [:election_date])\n    (tc/update-columns {:state (partial map count)})\n    (tc/order-by :election_date))\n\n_unnamed [7 2]:\n\n\n\n:election_date\n:state\n\n\n\n\n2012-11-06\n30\n\n\n2014-11-04\n32\n\n\n2016-02-09\n1\n\n\n2016-09-13\n1\n\n\n2016-11-08\n30\n\n\n2018-11-06\n32\n\n\n2020-11-03\n35\n\n\n\nNo year has as many states with data as the most recent year, so for the sake of this comparison we’ll compute the differences in polling station counts between the first and last years. We can do this by “folding” our dataset up by state, rolling up all the rows that share a state into one list:\n\n(-&gt; all-polling-locations\n    ;; first we'll group all the data by election date and state to\n    ;; get our dataset of polling place counts by date and state\n    (tc/group-by [:election_date :state])\n    (tc/aggregate {:count tc/row-count})\n    ;; we'll select only the rows from 2012 and 2020 so we can\n    ;; compare just those two counts\n    (tc/select-rows (fn [row]\n                      (let [year (-&gt; row :election_date .getYear)]\n                        (or (= 2012 year) (= 2020 year)))))\n    ;; sort this dataset by election date\n    (tc/order-by [:election_date])\n    ;; roll up the dates and counts by state\n    (tc/fold-by [:state])\n    ;; select only rows that have data for both elections\n    (tc/select-rows #(= 2 (count (:count %))))\n    ;; now we can compute the difference between the 2012 and 2020\n    ;; counts -- we'll compute this as a relative difference (i.e.\n    ;; relative to the 2012 value), for the sake of comparison, so\n    ;; that we can get a sense of how states compare to each other\n    ;; despite the large discrepancies in absolute numbers of polling places\n    (tc/map-columns :difference [:count] (fn [[c2012 c2020]]\n                                           (/ (- c2020 c2012)\n                                              c2012)))\n    ;; for the sake of seeing the relative differences in counts we only\n    ;; care about the state and our new computed column\n    (tc/select-columns [:state :difference]))\n\n_unnamed [26 2]:\n\n\n\n:state\n:difference\n\n\n\n\nCT\n-0.03364\n\n\nNH\n0.08654\n\n\nME\n0.08621\n\n\nIL\n-0.1534\n\n\nNC\n-0.03411\n\n\nMD\n-0.8340\n\n\nND\n0.5938\n\n\nAK\n0.1136\n\n\nOH\n-0.04132\n\n\nMA\n-0.0009195\n\n\n…\n…\n\n\nDE\n0.004630\n\n\nSC\n0.05645\n\n\nIA\n-0.004147\n\n\nAR\n-0.6187\n\n\nVT\n-0.01509\n\n\nMT\n-0.1501\n\n\nVA\n0.02771\n\n\nWV\n-0.07043\n\n\nNE\n-0.1409\n\n\nWI\n0.07667\n\n\nLA\n-0.07847\n\n\n\nNow we can see quantitatively what the visualizations above seemed to show – most states saw not much change in the number of polling stations. We can visualize this data as a bar chart and see the outliers pretty clearly:\n\n(-&gt; all-polling-locations\n    (tc/group-by [:election_date :state])\n    (tc/aggregate {:count tc/row-count})\n    (tc/select-rows (fn [row]\n                      (let [year (-&gt; row :election_date .getYear)]\n                        (or (= 2012 year) (= 2020 year)))))\n    (tc/order-by [:election_date])\n    (tc/fold-by [:state])\n    (tc/select-rows #(= 2 (count (:count %))))\n    (tc/map-columns :difference [:count] (fn [[c2012 c2020]]\n                                           (-&gt; c2020\n                                               (- c2012)\n                                               (/ c2012)\n                                               double)))\n    (hanami/plot (assoc ht/layer-chart :encoding :ENCODING)\n                 {:X :difference\n                  :XAXIS {:domain false :format \"1%\"\n                          :title \"Change in polling place count 2012-2020\"}\n                  :YSORT \"-x\"\n                  :Y :state\n                  :YTYPE \"nominal\"\n                  :YTITLE \"State\"\n                  :LAYER [{:mark \"bar\"}\n                          {:mark {:type \"text\"\n                                  :align {:expr \"datum.difference &lt; 0 ? 'right' : 'left'\"}\n                                  :dx {:expr \"datum.difference &lt; 0 ? -2 : 2\"}\n                                  }\n                           :encoding {:text {:field :difference\n                                             :format \".1%\"}}}]}))\n\n\n\n\n\n\nThere we have it! An interesting investigation of some data on polling places. See you next week :)\n\n\n\n\nsource: src/year_2024/week_3/analysis.clj",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Week 3 - US Polling Places 2012-2020</span>"
    ]
  }
]