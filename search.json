[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Clojure Tidy Tuesdays",
    "section": "",
    "text": "(ns index)\n\n\n1 Welcome to Clojure Tidy Tuesdays!\nThis is a collection of #TidyTuesday explorations in Clojure. Tidy tuesdays are an initiative of the R for data science online learning community, and as a Clojure enthusiast, I’m publishing implementations of the data-generation scripts and data explorations in Clojure here in 2024. Follow along to learn all about Clojure’s rich data ecosystem!\n\n\n\n\nsource: src/index.clj"
  },
  {
    "objectID": "year_2024.week_1.analysis.html#making-a-bar-chart",
    "href": "year_2024.week_1.analysis.html#making-a-bar-chart",
    "title": "2  Week 1 - Holiday Movies",
    "section": "2.1 Making a bar chart",
    "text": "2.1 Making a bar chart\nTo get started, we’ll load the data into our notebook, starting with the dataset of holiday movies:\n\n(def holiday-movies\n  (tc/dataset \"data/year_2024/week_1/holiday-movies.csv\"))\n\nWe’ll make a graph that’s similar to the one in this article about Christmas movies, showing the top 20 movies by number of votes. For this we’ll use noj, a library that nicely integrates hanami, a Clojure library that wraps vega-lite, with tablecloth. First we can tell it to make a bar chart:\n\n(-&gt; holiday-movies\n    ;; sort the movies by number of votes\n    (tc/order-by \"num_votes\" :desc)\n    ;; select the first 20\n    (tc/select-rows (range 20))\n    ;; make a bar chart\n    (hanami/plot ht/bar-chart {}))\n\n\n\n\n\n\nWe have to tell hanami what values to use in the chart and what they are:\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    (hanami/plot ht/bar-chart {:X \"num_votes\"\n                               :Y \"primary_title\"\n                               :YTYPE \"nominal\"}))\n\n\n\n\n\n\nThis works! We’ll give it a few more options to tidy up the chart, like sorting the bars by number of votes rather than alphabetically and re-labelling the axes:\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    (hanami/plot ht/bar-chart {:X \"num_votes\"\n                               :Y \"primary_title\"\n                               :YTYPE \"nominal\"\n                               :YTITLE \"Title\"\n                               :XTITLE \"Number of votes\"\n                               :YSORT \"-x\"}))"
  },
  {
    "objectID": "year_2024.week_1.analysis.html#adding-labels-to-the-bar-chart",
    "href": "year_2024.week_1.analysis.html#adding-labels-to-the-bar-chart",
    "title": "2  Week 1 - Holiday Movies",
    "section": "2.2 Adding labels to the bar chart",
    "text": "2.2 Adding labels to the bar chart\nIn order to add the number of votes values next to the bars we’ll have to rearrange some of the vega lite spec.. making this tidier and more intuitive is on the list of projects the Clojure data community is actively working on. I get that right now it requires too much information of vega-lite internals. Also it breaks the sorting and I don’t know why yet..\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    (hanami/plot (assoc ht/layer-chart :encoding :ENCODING)\n                 {:TITLE \"Christmas Movies\"\n                  :X \"num_votes\"\n                  :Y \"primary_title\"\n                  :YTYPE \"nominal\"\n                  :YTITLE \"Title\"\n                  :XTITLE \"Number of votes\"\n                  :YSORT \"-x\"\n                  :WIDTH 500\n                  :XSTACK nil\n                  :LAYER [{:mark {:type \"bar\"}}\n                          {:mark {:type \"text\" :align \"left\" :baseline \"middle\" :dx 3}\n                           :encoding {:text {:field \"num_votes\"}}}]}))\n\n\n\n\n\n\nThis is a similar idea to what’s accomplished in the article. We don’t have exactly the same data, so we can’t encode the Oscar status of each movie in the colour, but we could do something else, like indicate the decade in which the film was released. There are lots of ways to accomplish this. There would be a way to tell vega-lite to do it (via Hanami), but for the sake of exploring Clojure some more we’ll do the data wrangling part with it. To do that we’ll start with our dataset of the 20 most popular movies and add a column for the release decade, then update our plot to have the bars coloured by decade.\n\n(-&gt; holiday-movies\n    (tc/order-by \"num_votes\" :desc)\n    (tc/select-rows (range 20))\n    ;; add a new column for the decade, computed from the year\n    (tc/map-columns \"decade\" [\"year\"] (fn [year]\n                                        (-&gt; year\n                                            (/ 10)\n                                            (Math/floor)\n                                            (* 10)\n                                            int\n                                            (str \"s\"))))\n    ;; colour our bars according to the decade\n    (hanami/plot ht/bar-chart {:X \"num_votes\"\n                               :Y \"primary_title\"\n                               :YTYPE \"nominal\"\n                               :YTITLE \"Title\"\n                               :XTITLE \"Number of votes\"\n                               :YSORT \"-x\"\n                               :COLOR \"decade\"}))\n\n\n\n\n\n\nWithout the bar labels, this is reasonably straightforward."
  },
  {
    "objectID": "year_2024.week_1.analysis.html#making-a-word-cloud",
    "href": "year_2024.week_1.analysis.html#making-a-word-cloud",
    "title": "2  Week 1 - Holiday Movies",
    "section": "2.3 Making a word cloud",
    "text": "2.3 Making a word cloud\nThe next graph in the article is a graph of relationships between the movie keywords. We don’t have the keywords in our dataset, but we could do something with the words of the movie titles, like a word cloud, where the size of the word reflects its occurrence in the movie titles. First we’ll collect all of the words in all the titles into a list, then use those as the data for the word cloud. This is a little more involved with low-level vega details than is ideal right now, but it’s possible.\n\n(let [data (-&gt; holiday-movies\n               (tc/select-columns \"primary_title\")\n               tc/rows\n               flatten)]\n  (kind/vega {:data\n              [{:name \"table\"\n                :values data\n                :transform\n                [{:type \"countpattern\"\n                  :field \"data\"\n                  :case \"upper\"\n                  :pattern \"[\\\\w']{3,}\"\n                  :stopwords \"(the|a|i'm|like|too|into|ing|for|where|she|he|hers|his|how|who|what|your|yours|it|it's|is|are|we|'til|our|and|but|i'll|this|that|from|with)\"\n                  }\n                 {:type \"formula\",\n                  :as \"angle\",\n                  :expr \"[-45, -25, 0, 25, 45][~~(random() * 5)]\"}\n                 {:type \"formula\",\n                  :as \"weight\",\n                  :expr \"if(datum.text=='CHRISTMAS' |\n                            datum.text=='HOLIDAY' |\n                            datum.text=='HANNUKAH', 600, 300)\"}]}],\n              :scales\n              [{:name \"color\"\n                :type \"ordinal\",\n                :domain {:data \"table\", :field \"text\"},\n                :range [\"red\" \"green\" \"grey\" \"darkred\" \"darkgreen\"]}],\n              :marks\n              [{:type \"text\",\n                :from {:data \"table\"},\n                :encode\n                {:enter\n                 {:text {:field \"text\"},\n                  :align {:value \"center\"},\n                  :baseline {:value \"alphabetic\"},\n                  :fill {:scale \"color\", :field \"text\"}},\n                 :update {:fillOpacity {:value 1}},\n                 :hover {:fillOpacity {:value 0.5}}},\n                :transform\n                [{:fontSizeRange [10 56],\n                  :type \"wordcloud\",\n                  :font \"Helvetica Neue, Arial\",\n                  :size [800 400],\n                  :padding 2,\n                  :fontWeight {:field \"datum.weight\"},\n                  :rotate {:field \"datum.angle\"},\n                  :fontSize {:field \"datum.count\"},\n                  :text {:field \"text\"}}]}]}))\n\n\n\n\n\n\n\nSee you next week :)\n\n\n\n\nsource: src/year_2024/week_1/analysis.clj"
  },
  {
    "objectID": "year_2024.week_2.analysis.html#canadian-birth-months",
    "href": "year_2024.week_2.analysis.html#canadian-birth-months",
    "title": "3  Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "3.1 Canadian Birth Months",
    "text": "3.1 Canadian Birth Months\nThe data for this analysis are gathered from the NHL API and StatsCan. There are a bunch of files saved in data/year_2024/week_2 you can just use, or if you want to explore how the data is collected and cleaned up you can check out data/year_2024/week_2/generate_dataset.clj. We start with data on all Canadian births from 1991-2022 to see the distribution of Canadian births by month.\n\n(def canadian-births-by-month\n  (-&gt; \"data/year_2024/week_2/canada_births_1991_2022.csv\"\n      (tc/dataset {:key-fn keyword})\n      ;; group them by month\n      (tc/group-by [:month])\n      ;; count all births per month over the time period\n      (tc/aggregate {:country-births #(reduce + (:births %))})\n      ;; make a new column for the percentage of total births that each monthly total represents\n      (as-&gt; country-births-ds\n            (let [total-births (-&gt;&gt; country-births-ds\n                                    :country-births\n                                    (reduce +))]\n              (tc/map-columns country-births-ds\n                              :country-pct\n                              :country-births\n                              (fn [country-births]\n                                (-&gt; country-births\n                                    (/ total-births)\n                                    double)))))))\n\n\ncanadian-births-by-month\n\n_unnamed [12 3]:\n\n\n\n:month\n:country-births\n:country-pct\n\n\n\n\n1\n941370\n0.08015265\n\n\n2\n886150\n0.07545096\n\n\n3\n995978\n0.08480224\n\n\n4\n983363\n0.08372814\n\n\n5\n1029538\n0.08765969\n\n\n6\n1001064\n0.08523528\n\n\n7\n1042392\n0.08875414\n\n\n8\n1024021\n0.08718995\n\n\n9\n1019490\n0.08680416\n\n\n10\n982729\n0.08367415\n\n\n11\n918434\n0.07819978\n\n\n12\n920185\n0.07834886\n\n\n\nWe can plot this to make it easier to interpret:\n\n(-&gt; canadian-births-by-month\n    (hanami/plot (assoc ht/layer-chart :encoding :ENCODING)\n                 {:TITLE \"Canadian births by month 1991-2022\"\n                  :X :country-births\n                  :XTITLE \"Number of births (cumulatively)\"\n                  ;; vega-lite uses JS sorting, which does not sort numbers\n                  ;; properly, so we'll tell it what order to use explicitly\n                  :YSORT [\"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" \"10\" \"11\" \"12\"]\n                  :Y :month\n                  :YTITLE \"Month\"\n                  :YTYPE \"nominal\"\n                  :LAYER [{:mark \"bar\"}\n                          {:mark {:type \"text\" :align \"left\" :dx 3}\n                           :encoding {:text {:field :country-pct :format \".1%\"}}}]}))\n\n\n\n\n\n\nSo now we can see the distribution of births in Canada by month between 1991 and 2022. It actually looks like Canadians are less likely to be born in the earlier months of the year, with the most births in May, July, August, and September. We can compare this to the expected distribution (if each day had an exactly equal chance of being someone’s birthday) by first constructing a dataset of the “expected” monthly distributions:\n\n(def expected-births-by-month\n  (let [months [1 2 3 4 5 6 7 8 9 10 11 12]]\n    (tc/dataset {:month months\n                 :expected-births (map (fn [month]\n                                         (double (cond\n                                                   (#{4 6 9 11} month) 30/365\n                                                   (= month 2) 28/365\n                                                   :else 31/365)))\n                                       months)})))\n\nAnd then computing the differences between the “expected” monthly births and the actual Canadian data:\n\n(-&gt; expected-births-by-month\n    (tc/inner-join canadian-births-by-month :month)\n    (tc/map-columns :difference [:expected-births :country-pct]\n                    (fn [expected country]\n                      (- expected country))))\n\ninner-join [12 5]:\n\n\n\n\n\n\n\n\n\n\n:month\n:expected-births\n:country-births\n:country-pct\n:difference\n\n\n\n\n1\n0.08493151\n941370\n0.08015265\n0.00477885\n\n\n2\n0.07671233\n886150\n0.07545096\n0.00126136\n\n\n3\n0.08493151\n995978\n0.08480224\n0.00012927\n\n\n4\n0.08219178\n983363\n0.08372814\n-0.00153635\n\n\n5\n0.08493151\n1029538\n0.08765969\n-0.00272818\n\n\n6\n0.08219178\n1001064\n0.08523528\n-0.00304350\n\n\n7\n0.08493151\n1042392\n0.08875414\n-0.00382263\n\n\n8\n0.08493151\n1024021\n0.08718995\n-0.00225844\n\n\n9\n0.08219178\n1019490\n0.08680416\n-0.00461238\n\n\n10\n0.08493151\n982729\n0.08367415\n0.00125735\n\n\n11\n0.08219178\n918434\n0.07819978\n0.00399201\n\n\n12\n0.08493151\n920185\n0.07834886\n0.00658264\n\n\n\nWe can check the distribution for hockey players next."
  },
  {
    "objectID": "year_2024.week_2.analysis.html#canadian-nhl-hockey-player-birth-months",
    "href": "year_2024.week_2.analysis.html#canadian-nhl-hockey-player-birth-months",
    "title": "3  Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "3.2 Canadian NHL Hockey Player Birth Months",
    "text": "3.2 Canadian NHL Hockey Player Birth Months\nWe have a dataset that includes player info for all NHL players over all time. We’ll start by doing a similar breakdown to the one we did above for all Canadians.\n\n(def nhl-player-births-by-month\n  ;; first, load the dataset:\n  (-&gt; \"data/year_2024/week_2/nhl-player-births.csv\"\n      (tc/dataset {:key-fn keyword})\n      ;; filter out just Canadian players\n      (tc/select-rows #(= (:birth-country %) \"CAN\"))\n      ;; group the players by birth month\n      (tc/group-by [:birth-month])\n      ;; count the number of players per month\n      (tc/aggregate {:births tc/row-count})\n      ;; we'll add a new column where we compute the percentage of births that each monthly total represents\n      (as-&gt; player-births-ds\n          (let [total-births (-&gt;&gt; player-births-ds\n                                  :births\n                                  (reduce +))]\n            (tc/map-columns player-births-ds\n                            :player-pct\n                            :births\n                            (fn [births]\n                              (-&gt; births\n                                  (/ total-births)\n                                  double)))))))\n\nWe can make a similar bar chart to see how the distribution of hockey player births compares to the all-Canada data:\n\n(hanami/plot nhl-player-births-by-month\n             (assoc ht/layer-chart :encoding :ENCODING)\n             {:TITLE \"NHL player births by month\"\n              :X :births\n              :XTITLE \"Number of births\"\n              ;; vega-lite uses JS sorting, which does not sort numbers properly, so we'll tell it what order to use explicitly\n              :YSORT [\"JANUARY\"\n                      \"FEBRUARY\"\n                      \"MARCH\"\n                      \"APRIL\"\n                      \"MAY\"\n                      \"JUNE\"\n                      \"JULY\"\n                      \"AUGUST\"\n                      \"SEPTEMBER\"\n                      \"OCTOBER\"\n                      \"NOVEMBER\"\n                      \"DECEMBER\"]\n              :Y :birth-month\n              :YTITLE \"Month\"\n              :YTYPE \"nominal\"\n              :LAYER [{:mark \"bar\"}\n                      {:mark {:type \"text\" :align \"left\" :dx 3}\n                       :encoding {:text {:field :player-pct\n                                         :format \".1%\"}}}]})\n\n\n\n\n\n\nThese are definitely more distributed disproportionately through the early months of the year. We can compare them on top of each other to see more clearly next."
  },
  {
    "objectID": "year_2024.week_2.analysis.html#comparing-all-canadian-births-to-canadian-nhl-player-births",
    "href": "year_2024.week_2.analysis.html#comparing-all-canadian-births-to-canadian-nhl-player-births",
    "title": "3  Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "3.3 Comparing all Canadian births to Canadian NHL player births",
    "text": "3.3 Comparing all Canadian births to Canadian NHL player births\nWe’ll simplify and combine the datasets first, before visualizing them:\n\n(def combined-births-by-month\n  (let [canada-births (-&gt; canadian-births-by-month\n                        ;; clean up the month names so they are the same in both datasets\n                          (tc/update-columns {:month (fn [col]\n                                                       (map #(-&gt; % Month/of .name str/capitalize)\n                                                            col))}))\n        player-births (-&gt; nhl-player-births-by-month\n                          (tc/rename-columns {:birth-month :month\n                                              :births :player-births})\n                          (tc/update-columns {:month (partial map str/capitalize)}))\n        expected-births (-&gt; expected-births-by-month\n                            (tc/rename-columns {:expected-births :expected-births-pct})\n                            (tc/update-columns {:month (fn [col]\n                                                         (map #(-&gt; % Month/of .name str/capitalize)\n                                                              col))}))]\n    ;; join the datasets by month to make one dataset:\n    (-&gt; canada-births\n        (tc/inner-join player-births :month)\n        (tc/inner-join expected-births :month))))\n\nThe visualization in the linked article is a really great example of where ggplot really shines. I think it would be cool to explore how this might be possible to re-create with vega-lite (via the tools and wrappers we have around it Clojure), but for now we can visualize the data in a more simple way using a grouped bar chart. Since this is a pretty custom chart, I’m going to hand-write the vega-lite spec. There’s tons to learn about vega-lite, but the main takeaway for now is that you can pass any vega-lite (or vega) spec to Clojure’s vega-viz wrappers and it will render them:\n\n(hanami/plot combined-births-by-month\n             {:data {:values :DATA\n                     :format :DFMT}\n              :repeat {:layer [:expected-births-pct :country-pct :player-pct]}\n              :spec {:encoding {:y {:field :month\n                                    :type \"nominal\"\n                                    :axis {:title \"Month\"}\n                                    :sort [\"January\"\n                                           \"February\"\n                                           \"March\"\n                                           \"April\"\n                                           \"May\"\n                                           \"June\"\n                                           \"July\"\n                                           \"August\"\n                                           \"September\"\n                                           \"October\"\n                                           \"November\"\n                                           \"December\"]}}\n                     :layer [{:mark \"bar\"\n                              :height {:step \"12\"}\n                              :encoding {:x {:field {:repeat \"layer\"}\n                                             :type \"quantitative\"\n                                             :axis {:title \"Percentage of births\"\n                                                    :format \".0%\"}}\n                                         :color {:datum {:repeat \"layer\"}\n                                                 :type \"nominal\"\n                                                 :scale {:range [\"steelblue\" \"red\" \"black\"]}\n                                                 :legend {:title \"Group\"\n                                                          :labelExpr \"{'country-pct': 'Canada', 'player-pct': 'NHL Players', 'expected-births-pct': 'Expected'}[datum.label]\"}}\n                                         :yOffset {:datum {:repeat \"layer\"}}}}\n                             {:mark {:type \"text\" :dx -80 :fontSize 10.5}\n                              :encoding {:text {:field {:repeat \"layer\"} :format \".1%\"}\n                                         :color {:value \"white\"}\n                                         :yOffset {:datum {:repeat \"layer\"}}}}]}}\n             {})\n\n\n\n\n\n\nWhen the data are all side-by-side like this we can see pretty clearly that it’s true that NHL players are in fact more likely to be born in the earlier parts of the year."
  },
  {
    "objectID": "year_2024.week_2.analysis.html#chi-squared-test",
    "href": "year_2024.week_2.analysis.html#chi-squared-test",
    "title": "3  Week 2 - Canadian NHL Hockey Player Birth Months",
    "section": "3.4 Chi-squared test",
    "text": "3.4 Chi-squared test\nThe last thing the author of the original article does is a chi-squared test on the NHL player births distribution. A chi-squared test is one you can use to see whether a given variable follows a hypothesized distribution in a more quantitative way, so it’s basically a more stats-y way to show that the NHL player birth dates distribution is different than we would expect. I.e., it can answer, quantitatively, the question “what are the chances that a sample of birth dates would be distributed the way our NHL player birth dates dataset is, compared to the expected distribution?” In this case our “expected” distribution is based on the distribution by month of all Canadian births.\nIn Clojure, this test is already implemented in the fastmath library, but in the interest of teaching (and because I already did it the hard way first before I learned how to use the fastmath function), we can just do it manually.\nFirst we compute the chi statistic. The formula is \\[\\sum_{k=1}^{n}\\frac{(O_k - E_k)^2}{E_k}\\] where O is the actual value and E is the expected one. We can implement this in Clojure. The first thing we need is the expected values. Our “actual” values are the count of NHL player births by month, so we can compute the expected ones by applying the expected distribution (based on the Canadian births data):\n\n(def actual-and-expected-births\n  ;; first get the total count of player births\n  (let [total-player-births (-&gt;&gt; (tc/select-columns nhl-player-births-by-month [:births])\n                                 tc/rows\n                                 (map first)\n                                 (reduce +))\n\n      ;; clean up the month names so they are the same in both datasets\n        canada-births (-&gt; canadian-births-by-month\n                          (tc/update-columns {:month (fn [col]\n                                                       (map #(-&gt; % Month/of .name str/capitalize)\n                                                            col))}))]\n    ;; combine the Canadian data with the NHL player data to calculate the expected values\n    (-&gt; nhl-player-births-by-month\n        (tc/rename-columns {:birth-month :month\n                            :births :actual})\n        (tc/update-columns {:month (partial map str/capitalize)})\n        (tc/inner-join canada-births :month)\n        (tc/map-columns :expected\n                        [:country-pct]\n                        (fn [pct]\n                          (Math/round (* pct total-player-births))))\n        (tc/select-columns [:month :actual :expected]))))\n\n\nactual-and-expected-births\n\ninner-join [12 3]:\n\n\n\n:month\n:actual\n:expected\n\n\n\n\nJanuary\n542\n438\n\n\nFebruary\n533\n412\n\n\nMarch\n513\n464\n\n\nApril\n526\n458\n\n\nMay\n520\n479\n\n\nJune\n463\n466\n\n\nJuly\n437\n485\n\n\nAugust\n394\n477\n\n\nSeptember\n421\n475\n\n\nOctober\n383\n457\n\n\nNovember\n374\n428\n\n\nDecember\n361\n428\n\n\n\nThis gives us the expected values – the number of births we would expect per month if we randomly sampled the same number of births from the Canadian data as we have NHL player births. Now we can compute the chi squared statistic:\n\n(def chi-squared\n  (-&gt;&gt; (tc/select-columns actual-and-expected-births [:actual :expected])\n       tc/rows\n       (map (fn [[actual expected]]\n              ;; find the difference between the actual and expected values\n              (let [a-e (- actual expected)]\n                (-&gt; a-e\n                    ;; square it\n                    (* a-e)\n                    ;; divide it by the expected value\n                    (/ expected)))))\n       ;; sum them\n       (reduce +)\n       ;; make it a number instead of a fraction\n       double\n       Math/round))\n\n\nchi-squared\n\n\n134\n\nIn order to use this value to test whether our NHL player birth dates follow an “expected” distribution, we can calculate the P-value using a chi-squared distribution. This is also implemented in fastmath, in this case we’ll use it. The P value tells us what the probability is of observing the given discrepancy between the actual and expected values. The degrees of freedom is one less than the number of categories we have, so in our case 11.\n\n(require '[fastmath.stats :as stats])\n\n\n(require '[fastmath.random :as r])\n\n\n(stats/p-value (r/distribution :chi-squared {:degrees-of-freedom 11}) chi-squared)\n\n\n0.0\n\nInterpreting this, we can say there is a 0.0% chance that the NHL player birth data are sampled from the Canadian birth data. In other words, the probability that the NHL player birth distribution by month is a fluke is 0. It’s definitely anomalous, not a result of not having a large enough sample size.\nSo that wraps up our exploration of this data! I’d love to poke around some more and see how the distribution of NHL players by nationality breaks down over time, and play around with vega-lite some more to make cooler looking graphs. But here I am already late for next week’s tidy tuesday, so I’ll move on for now and come back once I’ve learned more.\nSee you next week :)\n\n\n\n\nsource: src/year_2024/week_2/analysis.clj"
  }
]